# デザインパターン比較一覧

| デザインパターン         | 概要 (意図)                                                                                      | オブジェクト指向 (OOP) 的アプローチ                                                                                    | 関数型 (FP) 的アプローチ                                                                                           |
|--------------------------|------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|
| **Strategy パターン**    | 複数のアルゴリズム(戦略)を同一のインターフェースで扱い、実行時に切り替えられるようにする。        | - 戦略を「クラス」として定義（共通インターフェースを実装する）<br>- `Context`(例: Product クラス) が戦略オブジェクトを保持し、`setDiscountStrategy()` などのメソッドで切り替える<br>- 同じオブジェクト内の「状態」を変更してアルゴリズムを差し替える                                                         | - 戦略を単なる「関数」として定義（同じシグネチャを持つ関数）<br>- データ（例: Product）を不変に扱い、割引方法を切り替えるときは「新しいデータ構造」を返す<br>- `updateDiscountFunction()` のような関数で「新しい割引関数」を差し込んだ新オブジェクトを作成し、元のオブジェクトは破壊しない                        |
| **Observer パターン**        | あるオブジェクト(Subject)の状態が変化したら、依存するオブジェクト(Observer)に自動で通知する。 | - `Subject` クラスが Observer をリスト管理し、`notify()` で一斉通知<br>- `Observer` は `update()` メソッドを持ち、それぞれの処理を実装<br>- クラス多態性を活かしやすく、追加の Observer クラスを作りやすい                                    | - Observer を単なる「同じシグネチャのコールバック関数」として扱う<br>- `createSubject()` でクロージャを使い、`observers` 配列を管理、`notify()` で関数を全呼び出し<br>- 購読者の状態(受信履歴)も関数的(不変)に管理できる                                              |
| **Decorator パターン**  | 既存オブジェクトに機能を追加するためにラップ(包む)   | - **Decorator クラス**を使い、同じインターフェースを実装<br>- デコレータが元オブジェクトを **継承ではなく**内包し、追加ロジックを実行<br>- 実行時に多重ラップして機能を順番に付与 | - **元のデータ**(例: `{ description, cost }`) → **新しいデータ**(機能追加分)<br>- 「デコレータ関数」を合成して、不変データに付加情報を持たせる<br>- クラス不要でシンプルだが、大規模化すると関数の組み合わせが多くなり整理が必要 |
| **Factory パターン** | オブジェクトの生成を一元管理し、呼び出し側が具体的なクラスや初期化処理を意識せずに済むようにする。 | - ファクトリクラスに `createSomething()` のようなメソッドを用意し、必要に応じて実行時に `new` するクラスを切り替える<br>- 呼び出し側は「どのクラスが返ってくるか」を知らなくてよい<br>- 新しいクラスを追加する場合も、ファクトリ内の生成ロジックを修正するだけで対応可能 | - 単なる関数として `createSomething(type: string): Data` を用意し、`switch`/`if` で返すオブジェクトを変える<br>- 返すのはクラスインスタンスでなく `{ name, price }` などの不変データでもOK<br>- 複雑な初期化処理をまとめて書き、呼び出し側をシンプルにできる |
| **Template Method パターン** | 処理の流れ(アルゴリズムの骨格)を抽象化し、一部のステップだけを差し替えられるようにする。 | - 抽象クラスにテンプレートメソッド(例: `prepareRecipe()`)を定義し、共通部分は実装、差し替えたい部分(例: `brew()`, `addCondiments()`)を `abstract` メソッドとする<br>- サブクラスが抽象メソッドを実装するだけで流れを変えずに一部の処理を切り替え可能 | - 共通処理の順序を行う関数(例: `prepareBeverage()`)を用意し、差し替えたいステップ(抽出や調味料追加など)をコールバック関数として引数で受け取る<br>- 同じ関数を呼ぶが、渡すコールバックを変えるだけで振る舞いが切り替わる |

本リポジトリ・ドキュメントでは、今後も随時デザインパターンを追加し、  
**OOP + FP での実装アプローチの違い**を分かりやすく整理していきます。