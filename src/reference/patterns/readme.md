# デザインパターン比較一覧

| デザインパターン         | 概要 (意図)                                                                                      | オブジェクト指向 (OOP) 的アプローチ                                                                                    | 関数型 (FP) 的アプローチ                                                                                           |
|--------------------------|------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|
| **Strategy パターン**    | 複数のアルゴリズム(戦略)を同一のインターフェースで扱い、実行時に切り替えられるようにする。        | - 戦略を「クラス」として定義（共通インターフェースを実装する）<br>- `Context`(例: Product クラス) が戦略オブジェクトを保持し、`setDiscountStrategy()` などのメソッドで切り替える<br>- 同じオブジェクト内の「状態」を変更してアルゴリズムを差し替える                                                         | - 戦略を単なる「関数」として定義（同じシグネチャを持つ関数）<br>- データ（例: Product）を不変に扱い、割引方法を切り替えるときは「新しいデータ構造」を返す<br>- `updateDiscountFunction()` のような関数で「新しい割引関数」を差し込んだ新オブジェクトを作成し、元のオブジェクトは破壊しない                        |
| **Observer パターン**        | あるオブジェクト(Subject)の状態が変化したら、依存するオブジェクト(Observer)に自動で通知する。 | - `Subject` クラスが Observer をリスト管理し、`notify()` で一斉通知<br>- `Observer` は `update()` メソッドを持ち、それぞれの処理を実装<br>- クラス多態性を活かしやすく、追加の Observer クラスを作りやすい                                    | - Observer を単なる「同じシグネチャのコールバック関数」として扱う<br>- `createSubject()` でクロージャを使い、`observers` 配列を管理、`notify()` で関数を全呼び出し<br>- 購読者の状態(受信履歴)も関数的(不変)に管理できる                                              |

本リポジトリ・ドキュメントでは、今後も随時デザインパターンを追加し、  
**OOP + FP での実装アプローチの違い**を分かりやすく整理していきます。