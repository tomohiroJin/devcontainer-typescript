# Template Method パターン (Template Method Pattern)

---

## Template Method パターン (Template Method Pattern)とは

**テンプレートメソッドパターン**は、**処理の流れ(アルゴリズムの骨格)を抽象的に定義し、部分的なステップをサブクラスやコールバックで実装させる**デザインパターンです。  
具体的には、**共通の流れ**をテンプレートメソッドとして定義し、サブクラスなどで「一部の処理だけ変更（フック）」できる仕組みを提供します。

- **OOPアプローチ**: 抽象クラスにテンプレートメソッド (`prepareRecipe()` など) を定義し、  
  共通部分を実装する一方、一部のステップ（`brew()`, `addCondiments()` など）を `abstract` メソッドとしてサブクラスに任せる。  
- **関数型アプローチ**: テンプレートメソッドに相当する「メインの関数」が共通処理の順序を決め、  
  一部の処理はコールバック関数を引数として受け取ることで差し替えられるようにする。

---

## 本リポジトリの概要

飲み物を作る手順を例に、テンプレートメソッドパターンを解説しています。  

1. **オブジェクト指向 (OOP) 版**  
   - 抽象クラス `CaffeineBeverage` が `prepareRecipe()` を定義し、  
     サブクラス（`Coffee`, `Tea`）で抽出方法や調味料の追加を実装。  
2. **関数型 (FP) 版**  
   - `prepareBeverage()` 関数が共通フロー（お湯を沸かす → 抽出 → カップに注ぐ → 調味料を加える）を定義し、  
     `brew()`、`addCondiments()` はコールバックとして差し替え可能にする。

---

## Template Method パターンとは

- **目的（意図）**
  - **手順(アルゴリズム)の大枠を共通化**し、詳細部分だけを差し替えられるようにする。  
  - 同じ処理の流れを使い回しつつ、一部だけ異なる挙動を容易にカスタマイズできる。

- **メリット**
  1. **共通部分の重複排除**  
     - 抽象クラスや共通関数で「基本の流れ」をまとめるため、各サブクラス/コールバックでの重複を減らせる。
  2. **拡張性が高い**  
     - 一部メソッド(あるいはコールバック)を差し替えるだけで、新たな振る舞いを追加しやすい。
  3. **一貫した流れの保証**  
     - 全体のフローが固定されるため、処理手順の統一や整合性を保ちやすい。

- **デメリット**
  1. **継承の制約 (OOP版)**  
     - クラス階層が増えすぎると可読性が下がり、変更の影響範囲も広くなる。
  2. **フローの柔軟性が制限される**  
     - テンプレートメソッドの順序自体を大きく変えたい場合、抽象クラスを再設計する必要がある。
  3. **関数型版でもコールバックが複雑化**  
     - 多数のフックが必要な場合、コールバックや引数が増えすぎて管理が難しくなる。

---

## オブジェクト指向 (OOP) での Template Method パターン

1. **抽象クラスにテンプレートメソッドを定義**  
   - 例: `CaffeineBeverage` に `prepareRecipe()` を定義し、  
     共通する処理(`boilWater()`, `pourInCup()`)を具体実装、  
     可変部分(`brew()`, `addCondiments()`)を `abstract` メソッドにする。
2. **サブクラスが抽象メソッドを実装**  
   - 例: `Coffee` と `Tea` が、それぞれ `brew()` と `addCondiments()` の実装を行う。  
   - テンプレートメソッド内で呼ばれるステップがサブクラスの実装で変わるため、**同じ流れの中で挙動を差し替え**られる。

## 関数型 (FP) での Template Method パターン

1. **共通処理を行う関数を用意**  
   - 例: `prepareBeverage()` 関数で「お湯を沸かす → 抽出 → カップに注ぐ → 調味料追加」の順序を固定。
2. **差し替え可能なステップはコールバック関数として引数で受け取る**  
   - 例: `brew()` / `addCondiments()` をオブジェクト(`BeverageSteps`)で渡して、そこだけ実装を切り替える。  
   - `prepareBeverage(coffeeSteps)` / `prepareBeverage(teaSteps)` のように、使うコールバックを変えるだけで動作が変わる。

---

## まとめ

- **テンプレートメソッドパターン**は「処理の骨格を共通化し、一部のステップだけを差し替えて使う」ための仕組み。  
- **OOP** では抽象クラスと継承で実現し、**流れ(テンプレートメソッド)** + **抽象メソッド(フック)** に分割。  
- **FP** では「共通処理を行う関数」と「差し替え可能なコールバック」を組み合わせて実装。  
- 大規模システムで類似パターンの処理が多い場合に、**重複排除**や**拡張性向上**の効果を得られる。  