# ストラテジーパターン(Strategy Pattern)

## ストラテジーパターン(Strategy Pattern)とは

ストラテジーパターンとは、「**複数のアルゴリズム(ロジック)を同じインターフェースで扱い、実行時に柔軟に切り替えられるようにする**」デザインパターンです。  
たとえば「割引計算」を例に挙げると、季節割引・まとめ買い割引・クーポン割引など、いくつもの計算方法（アルゴリズム）を用意しておき、どれを使うかを後から容易に切り替えられます。

---

## 本リポジトリの概要

本リポジトリでは、**割引計算**を題材として、ストラテジーパターンを2つのアプローチで実装したサンプルを用意しています:

1. **オブジェクト指向 (クラスベース) の実装**  
2. **関数型 (不変データを返す) の実装**

ここではコードそのものは省略し、それぞれの特徴的な部分やメリット・デメリットを中心に解説します。

---

## オブジェクト指向 (OOP) での実装のポイント

1. **クラスを使った「戦略(Strategy)」の表現**  
   - それぞれの割引アルゴリズム（例: 季節割引、まとめ買い割引など）を「クラス」として定義し、共通のインターフェース (たとえば `DiscountStrategy`) を実装します。  
   - これにより「新しい割引ロジックを追加したいとき」は、既存のコードを大きく変更せず、新しい戦略クラスを作成するだけで拡張が可能です。

2. **Context (文脈) にあたるクラスで戦略を保持**  
   - 例として `Product` クラスを作り、商品名や価格などに加えて「現在どの割引戦略を使うか」という情報を**メンバー変数**で持ちます。  
   - メソッド (`setDiscountStrategy`) を通じて戦略を差し替えることで、**実行時に動的にアルゴリズムを切り替えられる**ようになります。

3. **状態を変更しながら使う**  
   - オブジェクト指向では、`Product` オブジェクト自身が「どの戦略を保持しているか」という**可変状態**を持っていることが多いです。  
   - このため、メソッド呼び出しによって戦略を切り替えると、同じオブジェクトの内部状態が書き換わる形となります。

4. **メリット**  
   - **クラスやインターフェースを用いた多態性**がわかりやすい。  
   - 既存のオブジェクト指向フレームワークやツールと親和性が高い。  
   - 「責務の分離」が行いやすく、新戦略追加時の影響範囲が小さい。

5. **デメリット**  
   - 小規模なシステムではクラスやファイルが増えがちで、やや煩雑になる場合がある。  
   - 内部状態を持つため、同じオブジェクトの状態管理が複雑化する可能性がある。

---

## 関数型 (FP) での実装のポイント

1. **戦略を単なる「関数」として扱う**  
   - 「元の価格を受け取り、割引後の価格を返すだけ」という関数の型を定義し、そこに季節割引やまとめ買い割引といったロジックを実装します。  
   - いわゆる「同じシグネチャを持つ複数の関数」を「戦略」とみなすのが関数型でのアプローチです。

2. **商品データを「不変(immutable)」な形で扱う**  
   - たとえば商品データに「現在の割引関数」を含める場合でも、それを変更するときは**新しいオブジェクト**として返すようにします。  
   - 「状態を上書きしない」のが特徴で、常に**純粋関数**で扱いやすくなります。

3. **戦略の切り替えは「新しいデータを返す」形で行う**  
   - 関数型の考え方では、「商品A に別の戦略を適用した商品B」というように**別のデータ**として扱うのが基本です。  
   - これにより、元のデータ(商品A)が破壊されないので、過去の状態をそのまま保持・参照しやすいです。

4. **メリット**  
   - 不変データのため、副作用が少なくテストしやすい。  
   - 新しい戦略(関数)を追加する時は関数を1つ作るだけで済むため、スケールしやすい。  
   - 同じ引数なら必ず同じ結果が得られる（純粋関数的）ロジックを保ちやすい。

5. **デメリット**  
   - 「ある状態のオブジェクトを更新したい」という場合に「新しいオブジェクトを返す」ため、コードによってはオブジェクト生成が多くなる。  
   - オブジェクト指向に慣れた人には、ややとっつきにくい場合がある。  
   - 状態の変更を繰り返す場面では、差分管理の方法によってはメモリ使用量に注意が必要になる場合もある。

---

## 使い所・補足

- **ゲーム開発**  
  - キャラクターの攻撃パターンやAI思考ルーチンなどをクラス分割/関数分割する際、ストラテジーパターンが有効。  
  - 設定画面や難易度によってロジックを切り替えるのも簡単。

- **ビジネスロジック**  
  - 例として、請求書や支払いシステムで「国内向けの税率計算」「海外向けの税率計算」「クーポン割引」「定期購入割引」などを差し替える時に活用。

- **大規模開発におけるメリット**  
  - 新しい要件が追加されたときに「新しい戦略を作って差し込むだけ」にできるため、既存コードを大きく壊さずに拡張しやすい。

---

## まとめ

- **ストラテジーパターン**  
  - **「共通のインターフェース(or シグネチャ)を持つ複数のアルゴリズムを用意し、必要に応じて切り替える」**ためのデザインパターン。  
  - クラスでも関数型でも、本質は同じ。

- **オブジェクト指向アプローチ**  
  - クラスとインターフェースを用いた明確な多態性を表現できる。  
  - `setDiscountStrategy` のようなメソッドで内部状態を切り替え、同じオブジェクトを使い続ける。

- **関数型アプローチ**  
  - 戦略を単なる「引数→戻り値」の純粋関数として定義し、不変データ構造で扱う。  
  - 切り替え時には新しいオブジェクトを返すので、副作用が少なく安全。

---

以上が、割引ロジックを例にストラテジーパターンをオブジェクト指向と関数型で実装する際の特徴的な部分、およびパターン自体の概要です。  

### 参考

- [Gang of Four (GoF) Design Patterns](https://en.wikipedia.org/wiki/Strategy_pattern)  
- [関数型プログラミング](https://en.wikipedia.org/wiki/Functional_programming)  
- [オブジェクト指向プログラミング](https://ja.wikipedia.org/wiki/オブジェクト指向)  

いずれの手法も、**「アルゴリズムを差し替える」** というストラテジーパターンの要件を満たしており、開発するプロジェクトの規模やチームの技術的な背景に応じて選択可能です。