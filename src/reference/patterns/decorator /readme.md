# Decorator パターン (Decorator Pattern)

---

## Decorator パターン (Decorator Pattern)とは

**デコレーターパターン**は、**オブジェクトに機能を追加したいときに、そのオブジェクトを「包む」(ラップする)ことで動的に機能を拡張する**デザインパターンです。  
既存クラスを直接継承するのではなく、**同じインターフェースを実装するラッパー**をかぶせて振る舞いを追加します。これにより、クラスの増えすぎや複雑化を抑えつつ、必要な機能を柔軟に組み合わせて適用できます。

- **OOPアプローチ**: 「同じインターフェースを持つ Decorator クラス」がベースのオブジェクトを内包し、追加ロジックを注入。  
- **関数型アプローチ**: 「元のデータ(オブジェクト) → 新しいデータ(オブジェクト)」を返す**合成的な関数**を作り、機能を積み重ねる。  

---

## 本リポジトリの概要

コーヒーやエスプレッソなどの基本的な飲み物に、「ミルク」「砂糖」などを後から追加する例でデコレーターパターンを説明します。  

1. ベース飲み物 (Component) : コーヒー、エスプレッソ  
2. 追加機能 (Decorator) : ミルク、砂糖  

---

## Decorator パターンとは

- **目的（意図）**
  - **オブジェクトに機能を追加したいときに、そのオブジェクトを「包む」(ラップする)ことで動的に機能を拡張する**デザインパターンです。 
  - 既存クラスを直接継承するのではなく、**同じインターフェースを実装するラッパー**をかぶせて振る舞いを追加します。

- **メリット**
  1. **動的に機能を付け外しできる**  
     - 継承ではなく、オブジェクトをラップする(関数合成する)ので、実行時に組み合わせを自由に変更しやすい。  
  2. **単一責任の分離**  
     - 飲み物の基本部分と追加機能部分が別々のクラス(または関数)として定義されるため、拡張・管理がシンプル。  
  3. **クラスの爆発的増加を抑えられる**  
     - 「コーヒー with ミルク」「コーヒー with 砂糖」「コーヒー with ミルク & 砂糖」など、継承で全部作っていくと組み合わせ爆発が起きる。  
     - デコレータなら、必要な組み合わせをラップ(合成)するだけで対応可能。

- **デメリット**
  1. **インスタンスの連鎖**  
     - OOP ではデコレータを何重にも包むため、呼び出しが深くなるほどデバッグしづらい。  
  2. **複雑性**  
     - 小規模アプリでは単純な継承や if 文で済んでしまうこともあり、デコレータパターンがオーバーエンジニアリングになる可能性がある。  
  3. **順番の影響**  
     - 「砂糖 → ミルク」の順と「ミルク → 砂糖」の順で、説明文が変わる、あるいは価格計算に影響が出る場合は取り扱いに注意が必要 (FP でも同様)。  

---

## オブジェクト指向 (OOP) での Decorator パターン

1. **Beverage インターフェース**  
   - `getDescription(): string`, `cost(): number` を持つ  
2. **Concrete Component** (例: `Coffee`, `Espresso`)  
   - それぞれ具体的な説明と価格を返すクラス  
3. **抽象デコレータ (BeverageDecorator)**  
   - `Beverage` インターフェースを実装しつつ、内部に `Beverage` を持つ  
   - 継承先 (Concrete Decorator) で追加ロジックを実装  
4. **Concrete Decorator** (例: `MilkDecorator`, `SugarDecorator`)  
   - 飲み物の価格や説明に「ミルク」「砂糖」の情報を足して返す  
   - デコレータ同士を重ねられる (コーヒー → ミルクデコレータ → 砂糖デコレータ etc.)  

## 関数型 (FP) での Decorator パターン

1. **Beverage 型**  
   - `{ description: string; cost: number; }` のようなシンプルなデータ構造  
2. **ベース飲み物を作るファクトリ関数** (例: `createCoffee()`, `createEspresso()`)  
   - それぞれ `{ description: "コーヒー", cost: 150 }` のように返す  
3. **デコレータ関数** (例: `addMilk`, `addSugar`)  
   - `(Beverage) => Beverage` の形を持つ純粋関数  
   - 受け取った飲み物に「ミルク」や「砂糖」を足した**新しいデータ**を返す  
4. **合成**  
   - `addSugar(addMilk(coffee))` のように順番にチェーンでき、複数のデコレータを合成できる  

---

## まとめ

- **デコレーターパターンは「継承せずに機能を追加する」**方法として代表的。  
- **OOP** では「ベースクラス」「抽象デコレータ」「具体的デコレータ」の構造が典型的。  
- **FP** では「同じ型のデータを受け取って修飾された新しいデータを返す」関数として実現する。  
- いずれにしても、既存オブジェクトの責務を変更せず、**必要な機能のみを動的に追加・解除する**ことが可能となる。  

「コーヒーにミルク・砂糖を自由に追加する」「I/O ストリームにバッファ機能や暗号化機能を付与する」など、よくあるユースケースで利用されるパターンです。実際のプロジェクトでも、**複数の小さな機能を組み合わせて大きな機能を構築**したいときに大いに役立ちます。