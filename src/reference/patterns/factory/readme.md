# Factory パターン (Factory Pattern)

---

## Factory パターン (Factory Pattern)とは

**Factory パターン**は、**オブジェクトの生成を一箇所に集約し、呼び出し側が「どのクラスをインスタンス化するか」を意識せずに済むようにする**デザインパターンです。  
生成ロジックを工場(Factory)に集約することで、生成処理を整理しやすくなり、新しい種類のオブジェクトを追加・変更するときも影響範囲を抑えられます。

- **OOPアプローチ**:  
  - ファクトリクラスを用意し、`createSomething(type: string)` のようなメソッドでインスタンスを生成して返す。  
  - クライアント側は「どのクラスが生成されるか」を知らずに、ファクトリメソッドを呼び出すだけ。

- **関数型アプローチ**:  
  - 「文字列や識別子を入力 → 対応する不変データや関数を返す」関数を用意する。  
  - 必要に応じて追加の初期化手続きもファクトリ関数に閉じ込められる。

---

## 本リポジトリの概要

本リポジトリでは**ピザの生成**を例にしながら、Factory パターンをオブジェクト指向版と関数型版の 2 通りで解説しています。

1. **オブジェクト指向版**  
   - `PizzaFactory` クラスに `createPizza(pizzaType: string)` を定義し、文字列に応じて `CheesePizza`・`PepperoniPizza` などを生成します。  
2. **関数型版**  
   - `createPizza(pizzaType: string)` 関数を用意し、返り値として `{ name: string; price: number; }` を返す。  
   - 生成物は単純なデータオブジェクトで、クラスインスタンスを使わない実装です。

---

## Factory パターンとは

- **目的（意図）**  
  - 「オブジェクトの生成処理」を 1 つの場所にまとめて**呼び出し元の依存を減らす**。  
  - **生成する具体的なクラス名や初期化ロジックを隠蔽し**, 新しい種類のオブジェクトを追加した際も既存コードへの影響を小さくする。

- **メリット**  
  1. **生成ロジックの集中管理**  
     - どこでも `new Something()` を書くより、ファクトリメソッド経由の方が変更や拡張がしやすい。  
  2. **呼び出し側のコードがシンプル**  
     - どのクラスが返ってくるかを意識せずに、ただ「ファクトリを呼ぶ」だけで目的のオブジェクトを得られる。  
  3. **拡張が容易**  
     - 新しい種類のオブジェクトを追加するときは、ファクトリの生成処理を更新するだけでよい。  

- **デメリット**  
  1. **小規模だとオーバーエンジニアリングになりやすい**  
     - ただ `new` するだけで十分なケースでは、ファクトリが不要に見えるかもしれない。  
  2. **ファクトリが肥大化する可能性**  
     - `switch` 文や `if` 文が増えすぎると管理が難しくなる。  
  3. **クラス設計が複雑になる場合がある**  
     - 多機能で大規模な生成ロジックや、派生ファクトリが増える場合には注意が必要。

---

## オブジェクト指向 (OOP) での Factory パターン

1. **Factory クラスとプロダクトクラス**  
   - 例: `PizzaFactory` が `CheesePizza` や `PepperoniPizza` のインスタンスを生成して返す。  
   - クライアントは `PizzaFactory.createPizza("cheese")` のように呼び出すだけで済む。  

2. **拡張・管理がしやすい**  
   - 新しいピザを追加するなら、工場クラスの `createPizza` の中に `case "newpizza": return new NewPizza();` を1行書くだけでよい。  
   - 実行時に文字列を変えるだけで生成物を変えられる。

## 関数型 (FP) での Factory パターン

1. **単なる関数として実装**  
   - `createPizza(type: string): Pizza` のように書いて、`switch` 文で返すデータオブジェクトを変える。  
   - `Pizza` は `{ name: string; price: number }` のような**不変データ構造**で定義する。  
2. **インスタンスを使わずにデータを返す**  
   - オブジェクト指向のような `class` を継承しなくても、関数を追加するだけで新しい種類の生成物を拡張できる。  
   - 生成時に複雑な初期化がある場合も、すべてファクトリ関数内で行うので、呼び出し元は意識しなくて済む。

---

## まとめ

- **Factory パターン**は、**オブジェクトの生成を集中管理する**ことで、コードの重複や依存を減らすのが目的。  
- **オブジェクト指向版**は、ファクトリクラスを用いた多態的な設計に馴染む。  
- **関数型版**は、単なる関数と不変データでも「どのタイプのオブジェクトを返すか」を統合できる。  
- 小規模なら直接 `new` で事足りることも多いが、**拡張性や保守性を高める**ためにファクトリを導入すると便利。  