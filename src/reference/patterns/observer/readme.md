# オブサーバーパターン（Observer Pattern）

## オブサーバーパターン（Observer Pattern）とは

Observer パターンは、**あるオブジェクト(Subject)の状態が変化したときに、依存している他のオブジェクト(Observer)へ通知する**仕組みを提供するパターンです。  
ここでは「ニュース発行者(Subject)が新しい記事を発行すると、購読者(Observer)が通知を受け取る」という例を扱っています。

---

## 本リポジトリの概要

本リポジトリでは、「**ニュース配信システム**」を例に取り、**Observer パターン (監視者パターン)** を2つのアプローチで実装しています。

1. **オブジェクト指向 (クラス) を使った実装**  
2. **関数型 (不変データや関数で状態を扱う) を使った実装**

---

## Observer パターンとは

- **目的 (意図)**  
  - **「あるオブジェクトの状態が変わったときに、依存するオブジェクトへ自動的に通知を送る」**デザインパターンです。  
  - 発行者(Subject)と購読者(Observer)の**一対多**の関係を確立し、Subject が変化したら Observer に即座に通知できるようにします。

- **メリット**  
  1. **発行者(Subject)が購読者(Observer)の具体的実装を知らなくても良い**  
     → 新しい Observer が追加されても、Subject のコードは最小限の変更 (attach/detach のみ)  
  2. **購読者同士が互いを意識する必要がない**  
     → Observer は Subject に登録し、`update()` (あるいは対応するコールバック) を受け取るだけ。

- **デメリット**  
  1. **通知の順序や頻度が増えると、パフォーマンス面で考慮が必要**  
     → 多数の Observer が同時に通知を受ける場合、設計や最適化が難しくなる。  
  2. **循環参照 (Subject と Observer が互いを参照し合う) に注意が必要**  
     → メモリリークの原因になり得る。`detach` のタイミングなどを適切に管理する必要がある。

---

## オブジェクト指向 (OOP) での Observer パターン

1. **`Subject` インターフェース**  
   - `attach(observer: Observer)`, `detach(observer: Observer)`, `notify()` といったメソッドを持つ。  
   - Observer の登録/解除、通知処理を行う。

2. **`Observer` インターフェース**  
   - `update(message: string)` のように、Subject からの通知を受け取るメソッドを定義。  
   - 各具体的な購読者は、このインターフェースを実装し、受信時の振る舞いを記述する。

3. **`ConcreteSubject` (ニュース発行者)**  
   - `observers: Observer[]` の配列などを保持し、`publishNews()` で最新ニュースをセット → `notify()` で全 Observer に連絡。  

4. **`ConcreteObserver` (ニュース購読者)**  
   - `update(message: string)` が呼ばれたら、受け取ったニュースを内部に保持したり、画面表示・ログ出力などを行う。

5. **メリット (OOP)**  
   - クラス設計に馴染みがあるプロジェクトでは、Observer パターンの典型的な形を分かりやすく実装できる。  
   - 多態性を活かし、さまざまな「Observer の派生クラス」を追加しやすい。

6. **デメリット (OOP)**  
   - 小規模だとクラスやファイルが増えすぎる可能性がある。  
   - 内部状態を持つため、デバッグ時にどのタイミングで通知が飛んでいるかを追いにくい場合もある。

---

## 関数型 (FP) での Observer パターン

1. **Observer は「コールバック関数」として表現**  
   - `type ObserverFn = (message: string) => void;` のように、同じシグネチャの関数を複数登録しておき、一斉に呼ぶ形。

2. **Subject は「クロージャ + 配列管理」で表現**  
   - `createSubject()` のような関数で、内部に `observers: ObserverFn[]` を閉じ込めておき、`attach`, `detach`, `notify` などの関数を返す。  
   - 状態を直接上書きせず、新しい配列を返すなどの不変データ管理もできる。

3. **購読者の状態管理 (受信履歴など)**  
   - 「購読者が受け取ったメッセージ履歴」をどう保存するかは自由。  
   - たとえば `createObserver(name)` で、内部で `receivedMessages` を管理し、ObserverFn が呼ばれるたびに配列を更新する。  
   - 完全に不変にこだわるなら、更新のたびに新しい構造を返す形にもできる。

4. **メリット (FP)**  
   - クラスを作らずにシンプルに実装できる（ Observer は関数、Subject はクロージャ内配列など）。  
   - 不変データを使いやすく、副作用を最小化できる。

5. **デメリット (FP)**  
   - 結局「通知する」という挙動自体が副作用なので、完全な関数型パラダイムに当てはめることは難しい。  
   - 大規模なシステムでは、クラス継承による多態性のほうが見通しが良いケースもある。

---

## テスト方法の例

- **購読者を登録 → ニュースを発行 → 購読者が受信したか？**  
  - 2 人以上の購読者を登録してそれぞれの受信履歴を確認する。  
- **購読解除 → 新たなニュース発行 → 解除した購読者には届かないか？**  
  - 解除のタイミングや結果をテストし、Subject が正しく Observer のリストを管理しているかを確認。  
- **拡張シナリオ**  
  - 異なるチャンネル(Subject)を複数用意し、購読者がそれぞれを購読するケース。  
  - Observer の実装(クラスや関数)を多様化し、受信したらすぐ処理を完了するものと、バッファしてから処理するものを作って検証するなど。

---

## まとめ

1. **Observer パターンの意図**  
   - 「Subject が変化したら、依存している Observer に自動で通知する」仕組みを提供する。

2. **オブジェクト指向 (OOP) の実装**  
   - Observer インターフェースと Subject インターフェースを分離し、`attach/detach/notify` と `update` メソッドを使うのが典型。  
   - クラス設計を多用するプロジェクトに自然に馴染む。

3. **関数型 (FP) の実装**  
   - Observer を「同じシグネチャのコールバック関数」とし、Subject を「配列管理 + クロージャ」で構築する。  
   - 不変データや副作用排除の考え方を一部取り入れやすい。

4. **使い分け**  
   - OOP として標準的な形をとりたい場合はクラスベースの実装。  
   - なるべくクラスを増やしたくない、小規模 or 関数型で統一したいなら FP の実装がシンプルになる。

Observer パターンは、GUI アプリケーションでのイベント通知や、バックエンドでのイベント処理など、幅広く使われるパターンです。  
ここでは「ニュース配信システム」という分かりやすい例で実装しましたが、実際の用途や要件に応じてクラスベース or 関数ベースを選び、  
**「Subject が Observer を管理し、状態変化時に自動で通知する」という構造**をうまく活用してみてください。

## 参考資料

- [GoF デザインパターン - Observer](https://en.wikipedia.org/wiki/Observer_pattern)  
- [Pub/Sub パターンとの比較](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)  
- [関数型プログラミングの基礎](https://en.wikipedia.org/wiki/Functional_programming)  

本ドキュメントでは、同じニュース配信システムを題材に **オブジェクト指向 / 関数型** 両方の実装を紹介しました。実行時の手順やテストの流れは共通で、**違うのは「状態をどこで・どう持つか」**です。プロジェクトの設計方針やチームのスキルセットに応じて、使いやすいアプローチを選択してください。

